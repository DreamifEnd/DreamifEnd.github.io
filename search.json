[{"title":"hexo博客网站设置","url":"/2023/01/20/hexo%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E8%AE%BE%E7%BD%AE/","content":"# Sitetitle: Hexo  # 网站标题subtitle:    # 网站副标题description: # 网站描述author: John Doe  # 作者language:    # 语言timezone:    # 网站时区, Hexo默认使用您电脑的时区# URL## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27;## and root as &#x27;/child/&#x27;url: http://yoursite.com   # 你的站点Urlroot: /                    # 站点的根目录permalink: :year/:month/:day/:title/   # 文章的 永久链接 格式   permalink_defaults:        # 永久链接中各部分的默认值# Directory   source_dir: source     # 资源文件夹，这个文件夹用来存放内容public_dir: public     # 公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags          # 标签文件夹     archive_dir: archives  # 归档文件夹category_dir: categories     # 分类文件夹code_dir: downloads/code     # Include code 文件夹i18n_dir: :lang              # 国际化（i18n）文件夹skip_render:                 # 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。    # Writingnew_post_name: :title.md  # 新文章的文件名称default_layout: post      # 预设布局titlecase: false          # 把标题转换为 title caseexternal_link: true       # 在新标签中打开链接filename_case: 0          # 把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false      # 是否显示草稿post_asset_folder: false  # 是否启动 Asset 文件夹relative_link: false      # 把链接改为与根目录的相对位址    future: true              # 显示未来的文章highlight:                # 内容中代码块的设置      enable: true            # 开启代码块高亮  line_number: true       # 显示行数  auto_detect: false      # 如果未指定语言，则启用自动检测  tab_replace:            # 用 n 个空格替换 tabs；如果值为空，则不会替换 tabs# Category &amp; Tagdefault_category: uncategorizedcategory_map:       # 分类别名tag_map:            # 标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD     # 日期格式time_format: HH:mm:ss       # 时间格式    # Pagination## Set per_page to 0 to disable paginationper_page: 10           # 分页数量pagination_dir: page   # 分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape   # 主题名称# Deployment## Docs: https://hexo.io/docs/deployment.html#  部署部分的设置deploy:       type: &#x27;&#x27; # 类型，常用的git # 命令hexo new page --path log/logName &quot;logName&quot;"},{"title":"markdown使用","url":"/2023/01/27/markdown%E4%BD%BF%E7%94%A8/","content":"标题👆 看起来就像上面这个。Markdown 标题有两种格式。\n使用 = 和 - 标记一级和二级标题= 和 - 标记语法格式如下：\n我展示的是一级标题=================我展示的是二级标题-----------------\n\n使用 # 号标记使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。\n# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\n\n段落样式Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。当然也可以在段落后面使用一个空行来表示重新开始一个段落。\n字体Markdown 可以使用以下几种字体：\n\n斜体文本粗体文本粗斜体文本\n\n*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___\n\n分隔线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n\n我\n\n裂\n\n开\n\n了\n\n\n**** * ******- - -----------\n\n删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n\nRUNOOB.COMGOOGLE.COMBAIDU.COM\n\nRUNOOB.COMGOOGLE.COM~~BAIDU.COM~~\n\n下划线下划线可以通过 HTML 的 &lt;u&gt; 标签来实现：\n\n带下划线文本\n\n&lt;u&gt;带下划线文本&lt;/u&gt;\n\n脚注脚注是对文本的补充说明。Markdown 脚注的格式如下:\n[^要注明的文本]\n以下实例演示了脚注的用法：\n\n阿米娅^阿米娅\n\n创建脚注格式类似这样 [^阿米娅][^阿米娅]: 博士，您还有很多事情需要处理。现在还不能休息哦。\n\nMarkdown 列表Markdown 支持有序列表和无序列表。无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记：\n\n\n第一项\n第二项\n第三项\n\n\n* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项\n有序列表使用数字并加上 . 号来表示，如：\n\n\n第一项\n第二项\n第三项\n\n\n1. 第一项2. 第二项3. 第三项\n\n列表嵌套列表嵌套只需在子列表中的选项添加四个空格即可：\n\n第一项：\n第一项嵌套的第一个元素\n第一项嵌套的第二个元素\n\n\n第二项：\n第二项嵌套的第一个元素\n第二项嵌套的第二个元素\n\n\n\n1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素\n\nMarkdown 区块Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：\n\n这是一个区块\n\n&gt; 这是一个区块\n另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：\n\n最外层\n\n第一层嵌套\n\n第二层嵌套\n\n\n\n&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套\n\n区块中使用列表区块中使用列表实例如下：\n\n区块中使用列表\n\n第一项\n第二项\n\n\n第一项\n第二项\n第三项\n\n\n&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项\n\n列表中使用区块如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。区块中使用列表实例如下：\n\n第一项\n菜鸟教程学的不仅是技术更是梦想\n\n\n第二项* 第一项    &gt; 菜鸟教程    &gt; 学的不仅是技术更是梦想* 第二项\n\nMarkdown 代码如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：printf() 函数\n`printf()` 函数\n代码区块代码区块使用 4 个空格或者一个制表符（Tab 键）。也可以用 &#96;&#96;&#96; 包裹一段代码，并指定一种语言（也可以不指定）：实例如下：\n$(document).ready(function () &#123;    alert(&#x27;RUNOOB&#x27;);&#125;);\n\nMarkdown 链接链接使用方法如下：\n\n链接名称或者直接使用链接地址https://github.com/Yue-plus\n\n[链接名称](链接地址)&lt;https://github.com/Yue-plus&gt;\n\n高级链接可以通过变量来设置一个链接，变量赋值在文档末尾进行：\n\n这个链接用 1 作为网址变量 Google这个链接用 mysite 作为网址变量 Yue_plus\n\n这个链接用 1 作为网址变量 [Google][1]这个链接用 mysite 作为网址变量 [Yue_plus][mysite]然后在文档的结尾为变量赋值（网址）  [1]: http://www.google.com/  [mysite]: https://github.com/Yue-plus\n\nMarkdown 图片Markdown 图片语法格式如下：\n![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)\n开头一个感叹号 !接着一个方括号，里面放上图片的替代文字接着一个英文括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。\n\n\n\n![罗德岛集结](https://ak.hypergryph.com/upload/images/20190228/118078295785f64dac736c6ade50bb76.jpg &quot;罗德岛集结&quot;)\n当然，你也可以像网址那样对图片网址使用变量:\n这个链接用 `2` 作为网址变量 [凯尔希][2].然后在文档的结尾为变量赋值（网址）[2]: https://ak.hypergryph.com/upload/images/20190228/143666074a406ecaa6cd4271dc7c5127.jpg\nMarkdown 还没有办法指定图片的高度与宽度，如果需要的话，也可以使用普通的 &lt;img&gt; 标签。\n\n\n\n&lt;img src=&quot;https://ak.hypergryph.com/assets/index/images/ak/common/story/item_infected.png&quot; width=&quot;200px&quot;&gt;\n\nMarkdown 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。语法格式如下：\n\n\n\n表头\n表头\n\n\n\n单元格\n单元格\n\n\n单元格\n单元格\n\n\n|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |\n\n可以设置表格的对齐方式：\n-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。\n\n\n\n左对齐\n右对齐\n居中对齐\n\n\n\n单元格\n单元格\n单元格\n\n\n单元格\n单元格\n单元格\n\n\nMarkdown 高级技巧##支持的 HTML 元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等，如：\n\n使用 Ctrl+Alt+Del 重启电脑\n\n使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑\n\n转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：\n\n** 正常显示星号 **\n\n**文本加粗** \\*\\* 正常显示星号 \\*\\*\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\\   反斜线`   反引号*   星号_   下划线&#123;&#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号\n\n\n\n"},{"title":"相对论-光速不变假设","url":"/2023/03/15/%E7%9B%B8%E5%AF%B9%E8%AE%BA-%E5%85%89%E9%80%9F%E4%B8%8D%E5%8F%98%E5%81%87%E8%AE%BE/","content":"光速不变原理在任何参考系中,光在真空中的传播速度为一个常量不随光源或参考系的相对运动而改变\n\n设A点一个物体以光速向B方向运动同时在A处设置一个运动点,该点一无限接近光速得到速度向物体追去\n以傍观者为参照系运动点与物体无限接近,以光速进行运动\n以运动点位参照系物体以光速向自己逃离,相对以自身与物体总是差一个光速\n任何光线在”静止的”坐标系中都是以确定的V在运动着不管这条光线是从静止的还是运动的物体发射出来的\n\n尺缩效应","categories":["相对论"],"tags":["物理"]},{"title":"图表示例","url":"/2023/01/27/%E5%9B%BE%E8%A1%A8%E7%A4%BA%E4%BE%8B/","content":"\n\n主题通过 mermaid-js（GitHub）绘制各种图表。\n支持：\n\n流程图\n序列图\n类图\n状态图\n实体关系图\n用户旅程图\n甘特图\n指令图\n饼图\n\n\n关于写作那些事之快速上手 Mermaid 流程图\n\n流程图\n\ngraph LR\n    A[Hard edge] -->|Link text| B(Round edge)\n    B --> C{Decision}\n    C -->|One| D[Result one]\n    C -->|Two| E[Result two]\n\n\n&lt;div class=&quot;mermaid&quot;&gt;graph LR    A[Hard edge] --&gt;|Link text| B(Round edge)    B --&gt; C&#123;Decision&#125;    C --&gt;|One| D[Result one]    C --&gt;|Two| E[Result two]&lt;/div&gt;\n\n序列图\n\nsequenceDiagram\n    autonumber\n    Alice->>John: Hello John, how are you?\n    loop Healthcheck\n        John->>John: Fight against hypochondria\n    end\n    Note right of John: Rational thoughts!\n    John-->>Alice: Great!\n    John->>Bob: How about you?\n    Bob-->>John: Jolly good!\n\n\n&lt;div class=&quot;mermaid&quot;&gt;sequenceDiagram    autonumber    Alice-&gt;&gt;John: Hello John, how are you?    loop Healthcheck        John-&gt;&gt;John: Fight against hypochondria    end    Note right of John: Rational thoughts!    John--&gt;&gt;Alice: Great!    John-&gt;&gt;Bob: How about you?    Bob--&gt;&gt;John: Jolly good!&lt;/div&gt;\n\n类图\n\nclassDiagram\nclassA --|> classB : Inheritance\nclassC --* classD : Composition\nclassE --o classF : Aggregation\nclassG --> classH : Association\nclassI -- classJ : Link(Solid)\nclassK ..> classL : Dependency\nclassM ..|> classN : Realization\nclassO .. classP : Link(Dashed)\n\n\n&lt;div class=&quot;mermaid&quot;&gt;classDiagramclassA --|&gt; classB : InheritanceclassC --* classD : CompositionclassE --o classF : AggregationclassG --&gt; classH : AssociationclassI -- classJ : Link(Solid)classK ..&gt; classL : DependencyclassM ..|&gt; classN : RealizationclassO .. classP : Link(Dashed)&lt;/div&gt;\n\n状态图\n\n    stateDiagram-v2\n        State1: The state with a note\n        note right of State1\n            Important information! You can write\n            notes.\n        end note\n        State1 --> State2\n        note left of State2 : This is the note to the left.\n\n\n&lt;div class=&quot;mermaid&quot;&gt;    stateDiagram-v2        State1: The state with a note        note right of State1            Important information! You can write            notes.        end note        State1 --&gt; State2        note left of State2 : This is the note to the left.&lt;/div&gt;\n\n实体关系图\n\nerDiagram\n    CUSTOMER ||--o{ ORDER : places\n    ORDER ||--|{ LINE-ITEM : contains\n    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses\n\n\n&lt;div class=&quot;mermaid&quot;&gt;erDiagram    CUSTOMER ||--o&#123; ORDER : places    ORDER ||--|&#123; LINE-ITEM : contains    CUSTOMER &#125;|..|&#123; DELIVERY-ADDRESS : uses&lt;/div&gt;\n\n用户旅程图\n\njourney\n    title My working day\n    section Go to work\n      Make tea: 5: Me\n      Go upstairs: 3: Me\n      Do work: 1: Me, Cat\n    section Go home\n      Go downstairs: 5: Me\n      Sit down: 5: Me\n\n\n&lt;div class=&quot;mermaid&quot;&gt;journey    title My working day    section Go to work      Make tea: 5: Me      Go upstairs: 3: Me      Do work: 1: Me, Cat    section Go home      Go downstairs: 5: Me      Sit down: 5: Me&lt;/div&gt;\n\n甘特图\n\ngantt\n    title A Gantt Diagram\n    dateFormat  YYYY-MM-DD\n    section Section\n    A task           :a1, 2014-01-01, 30d\n    Another task     :after a1  , 20d\n    section Another\n    Task in sec      :2014-01-12  , 12d\n    another task      : 24d\n\n\ngantt    title A Gantt Diagram    dateFormat  YYYY-MM-DD    section Section    A task           :a1, 2014-01-01, 30d    Another task     :after a1  , 20d    section Another    Task in sec      :2014-01-12  , 12d    another task      : 24d&lt;/div&gt;\n\n指令图\n\n%%{init: { 'logLevel': 'debug', 'theme': 'dark' } }%%\nsequenceDiagram\n%%{config: { 'fontFamily': 'Menlo', 'fontSize': 18, 'fontWeight': 400} }%%\nAlice->>Bob: Hi Bob\nBob->>Alice: Hi Alice\n\n\n&lt;div class=&quot;mermaid&quot;&gt;%%&#123;init: &#123; &#x27;logLevel&#x27;: &#x27;debug&#x27;, &#x27;theme&#x27;: &#x27;dark&#x27; &#125; &#125;%%sequenceDiagram%%&#123;config: &#123; &#x27;fontFamily&#x27;: &#x27;Menlo&#x27;, &#x27;fontSize&#x27;: 18, &#x27;fontWeight&#x27;: 400&#125; &#125;%%Alice-&gt;&gt;Bob: Hi BobBob-&gt;&gt;Alice: Hi Alice&lt;/div&gt;\n\n饼图\n\npie\n    title Key elements in Product X\n    \"Calcium\" : 42.96\n    \"Potassium\" : 50.05\n    \"Magnesium\" : 10.01\n    \"Iron\" :  5\n\n\n&lt;div class=&quot;mermaid&quot;&gt;pie    title Key elements in Product X    &quot;Calcium&quot; : 42.96    &quot;Potassium&quot; : 50.05    &quot;Magnesium&quot; : 10.01    &quot;Iron&quot; :  5&lt;/div&gt;"},{"title":"二分","url":"/2023/03/30/%E4%BA%8C%E5%88%86/","content":"二分查找对于一些问题,满足下列条件\n\n由问题抽象出一个区间,使目标值一定在这个区间中\n找一个性质,满足: 1).  区间具有二段性 2).  答案是二段的分界点\n\n我们可以使用二分来解决.\n整数二分","categories":["数据结构与算法"],"tags":["C++"]},{"title":"递归与递推","url":"/2023/03/29/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/","content":"递归–排列问题一 递归实现排列型枚举对于n个数的排列,我们可以先枚举出所有情况,如下图所示:这里的排列是按照字典序来排的有n个数的排列,每一结果就有n位我们需要开辟大小为n的数组来暂存每一位的结果 const int N = 20;int arr[N];对于每一位出现的数字,其范围也是 1~n 的粗略的估计一下有n!种情况\n\n\n\n此时我们选用递归来操作,我们重点要关注的是数的位数和数的个数.我们这里以数的位数为主,排列需要一位一位来确定,确定好前一位才能确定下一位,所以我们将递归参数设成数的位数.由此我们画出递归搜索树\n\n   \n\n我们写一个递归函数,决定参数为层u\n\n void dfs(int u)&#123;    //...&#125;\n\n我们来看递归结束条件:当当前层数u&gt;数的位数n时,递归返程,我们这里直接打印.\n\nvoid dfs(int u) &#123;    if(u &gt; n)    &#123;\t\tfor(int i = 1; i &lt;= n ; i++)\t\t&#123;\t\t\tprintf(&quot;%d&quot;,arr[i]);\t\t&#125;\t\tputs(&quot;&quot;);  //打印空格\t&#125; &#125;\n\n\n每一位有1 ~ n可以填,   但后面填的数不能和前面重复,所以我们还要判定数是否用过所以我们新开辟一个数组来判断bool bl[N];\n\nvoid dfs(int u)&#123;    //...    for(int i = 1; i &lt;= n ; i++)    &#123;\t\tif (!bl[i])        //我们取到没有用过的数字        &#123;            bl[i] = true;  //使用这个数字            arr[u] = i;    //存起来            dfs(u + 1);    //递归下一层            bl[i] = false; //递归返回,数字重新置false,表示现在没用过了        &#125;    &#125;&#125;\n\n\n我们从第一层开始递归.\n\nint main()&#123;\tscanf(&quot;%d&quot;,&amp;n);\tdfs(1); // 开始递归\treturn 0;&#125;\n\n\n完整代码如下,时间复杂度为$O(n*n!)$\n\n#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;int n;int arr[16];bool bl[16];void dfs(int u)&#123;    if(u&gt;n)    &#123;        for(int i = 1; i &lt;= n ; i++)        &#123;            printf(&quot;%d &quot;,arr[i]);        &#125;        puts(&quot;&quot;);    &#125;    for(int i = 1; i &lt;= n; i++)    &#123;        if(!bl[i])        &#123;            bl[i]=true;            arr[u]=i;            dfs(u+1);            bl[i]=false;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d&quot;,&amp;n);    dfs(1);    return 0;    &#125;\n\n\n我们还可以用vector来存下所有的排列,代码如下\n\n#include&lt;bits/stdc++.h&gt;using namespace std;int n;const int N = 20;vector&lt; vector&lt;int&gt; &gt; ways;vector&lt;int&gt; way;int arr[N];bool bl[N];void dfs(int u)&#123;    if (u &gt; n)    &#123;        for (int i = 1; i &lt;= n; i++)        &#123;            way.push_back(arr[i]);        &#125;        ways.push_back(way);        way.clear();        return;    &#125;    for (int i = 1; i &lt;= n; i++)    &#123;        if (!bl[i])        &#123;            bl[i] = true;            arr[u] = i;            dfs(u + 1);            bl[i] = false;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    dfs(1);    for (auto it = ways.begin(); it != ways.end(); it++)    &#123;        auto vec = *it;        for (auto it2 = vec.begin(); it2 != vec.end(); it2++)            printf(&quot;%d &quot;, *it2);        puts(&quot;&quot;);    &#125;    return 0;&#125;\n\n二 递归实现组合型枚举\n组合相对于排列,删去了数字相同的情况.首先我们先画出递归搜索树(这里因大小原因只画了第一个子树)\n\n\n\n可以看到数的位数与数的个数不再一一对应我们同样以树的位数为主\n\nvoid dfs(int u)&#123;\tif(u &gt; n)  //边界条件\t&#123;\t\tfor(int i = 1; i &lt;= n; i++)\t\t&#123;\t\t\tprintf(&quot;%d&quot;,arr[i]);\t\t&#125;\t\tputs(&quot;&quot;);\t\treturn;\t&#125;\tfor(int i = 1; i &lt;= n; i++)\t&#123;\t\t//...\t&#125;&#125;\n\n对于&#x2F;&#x2F;…里的内容,应当完成从当前数字到m的赋值操作为此我们还需要知道当前数的位数与当前数\n\nvoid dfs(int u,int start,int d)\n\n形参新加一个当前从哪开始的start和当前对第几位操作的d\n\nfor(int i = 1; i &lt;= n; i++) //数的位数\t&#123;\t\twhile(start &lt;= m) //从当前一直取到m\t\t&#123;\t\t\tif(d &gt; n) d = n; //超出位数n的,操作尾位\t\t\tarr[d]=start;\t\t\tdfs(u+1,start+1,d+1); //递归下一层\t\t\tstart++; //改变start,使while能结束\t\t&#125;\t&#125;\n\n完整代码如下\n#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 30;int n,m;int arr[N];void dfs(int u,int start,int d)&#123;\tif(u &gt; n)\t&#123;\t\tfor(int i = 1; i &lt;= n; i++)\t\t\tprintf(&quot;%d &quot;,arr[i]);\t\tputs(&quot;&quot;);\t\treturn;\t&#125;\tfor(int i = 1; i &lt;= n; i++)\t&#123;\t\twhile(start &lt;= m)\t\t&#123;\t\t\tif(d &gt; n) d = n;\t\t\tarr[d]=start;\t\t\tdfs(u+1,start+1,d+1);\t\t\tstart++;\t\t&#125;\t&#125;\t&#125;int main()&#123;\tscanf(&quot;%d %d&quot;,&amp;m,&amp;n);\tdfs(1,1,1);\treturn 0;&#125;\n\n其实还有另一种方法,不以位数为主,而以数本身为主.代码如下\n\n#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,arr[20];void dfs(int x)&#123;    if (arr[0]==m)    &#123;        for (int j=1;j&lt;=p[0];j++)            printf(&quot;%d &quot;,arr[i]);        puts(&quot;&quot;);        return ;    &#125;    for (int i = x; i &lt;= n; i++)    &#123;        arr[++arr[0]]=i;        dfs(i+1);        arr[arr[0]--]=0;    &#125;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    dfs(1);    return 0;&#125;\n\n至此递归结束.\n总结\n解题思路: 当时间复杂度在$O(N!)$及以上(指数级别)时,我们根据情况选择用递归处理\n\n画出递归搜索树\n根据递归搜索树来决定递归函数的参数\n将递归搜索树转换成代码(核心)\n\n\n","categories":["数据结构与算法"],"tags":["C++"]}]